import { screen } from 'electron';

import { FRAME_DEFAULT_SIZE, FRAME_MIN_SIZE } from '@/isomorphic/const-size';
import { roundRectValue } from '@/isomorphic/shape';
import { desktopAppStore } from '../store/desktopApp';

export function getWindowBoundsInWorkArea(
  inputBounds: Partial<Electron.Rectangle>
) {
  const expectedBounds = {
    x: inputBounds?.x || 0,
    y: inputBounds?.y || 0,
    width: inputBounds?.width || FRAME_MIN_SIZE.minWidth,
    height: inputBounds?.height || FRAME_MIN_SIZE.minHeight,
  };

  const display = screen.getDisplayMatching(expectedBounds);
  const { workArea } = display;

  // determine final width
  if (workArea.width < FRAME_MIN_SIZE.minWidth) {
    expectedBounds.width = Math.min(expectedBounds.width, workArea.width);
  } else {
    expectedBounds.width = Math.max(
      expectedBounds.width,
      FRAME_MIN_SIZE.minWidth
    );
  }

  // determine final width
  if (workArea.height < FRAME_MIN_SIZE.minHeight) {
    expectedBounds.height = Math.min(expectedBounds.height, workArea.height);
  } else {
    expectedBounds.height = Math.max(
      expectedBounds.height,
      FRAME_MIN_SIZE.minHeight
    );
  }

  // fix x
  if (expectedBounds.x + expectedBounds.width > workArea.x + workArea.width) {
    expectedBounds.x = workArea.x + workArea.width - expectedBounds.width;
  }
  // fix y
  if (expectedBounds.y + expectedBounds.height > workArea.y + workArea.height) {
    expectedBounds.y = workArea.y + workArea.height - expectedBounds.height;
  }

  roundRectValue(expectedBounds);

  return expectedBounds;
}

export function getMainWinLastPosition() {
  const pos = desktopAppStore.get('lastWindowPosition');

  const expectedBounds = getWindowBoundsInWorkArea({
    x: pos.x || 0,
    y: pos.y || 0,
    width: pos.width || FRAME_DEFAULT_SIZE.width,
    height: pos.height || FRAME_DEFAULT_SIZE.height,
  });

  return expectedBounds;
}

export function setMainWindowBounds(
  mainWindow: Electron.BrowserWindow,
  bounds: Electron.Rectangle,
  animated = false
) {
  const minSize = mainWindow.getMinimumSize();

  roundRectValue(bounds);
  if (bounds.width !== minSize[0] || bounds.height !== minSize[1]) {
    minSize[0] = Math.min(minSize[0], bounds.width);
    minSize[1] = Math.min(minSize[1], bounds.height);
    mainWindow.setMinimumSize(minSize[0], minSize[1]);
  }

  mainWindow.setBounds(bounds, animated);
}

export function checkIfWindowFullfilledScreen(
  windowOrWindowBounds: Electron.BrowserWindow | Electron.Rectangle,
  screenDisplay?: Electron.Display
) {
  const bounds =
    typeof (windowOrWindowBounds as any).getBounds === 'function'
      ? (windowOrWindowBounds as any).getBounds()
      : windowOrWindowBounds;

  const matchedScreen =
    screenDisplay ||
    screen.getDisplayMatching({
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: bounds.height,
    });

  // check if main window is maximized to screen
  const isDockFullfilled =
    bounds.x - matchedScreen.workArea.x <= 5 &&
    bounds.y - matchedScreen.workArea.y <= 5 &&
    matchedScreen.workArea.width - bounds.width <= 5 &&
    matchedScreen.workArea.height - bounds.height <= 5;

  return { isDockFullfilled };
}
